\chapter{Monte Carlo Synthetic Acceleration Methods for the
  Navier-Stokes \\Equations\ }
\label{ch:nonlinear_problem}
Nonlinear transport problems are a common occurrence in single and
multiple physics problems. Systems of partial differential equations
such as those that describe fluid flow or more general transport
processes when discretized by conventional methods yield discrete sets
of stiff equations with nonlinearities present in the
variables. Traditionally, such systems have been solved by linearizing
them in a form where the nonlinearities in the variables are
eliminated and more traditional linear methods can be used for
solutions. Often characterized as segregated methods where physics
operators are split and their action on the system approximated in
steps, such methods lack consistency and accuracy in resolving the
nonlinear component of the solution. In the last 30 years, fully
consistent nonlinear methods based on Newton's method have become more
popular and many advances have been made in the computational physics
field to employ these methods.

In the context of solving standalone linear systems, Monte Carlo
methods do not provide significant merit over Krylov methods due to
the fact that the linear operator must be explicitly formed. For many
applications, such a requirement is prohibitive and perhaps not even
feasible to implement. Therefore, a Monte Carlo solver is best suited
for situations in which not only are Krylov methods applicable, but
also in which the operator is readily, if not naturally,
formed. Modern nonlinear methods meet both of these requirements with
Newton methods used in conjunction with Krylov methods for a robust
solution strategy. Furthermore, modern techniques exist that permit
the automatic construction of the linear operator generated within a
Newton method based on the nonlinear residual evaluations, providing
all of the components necessary for a Monte Carlo solver to provide
value. We therefore devise a new nonlinear method based on the MCSA
algorithm and Newton's method and discuss its potential benefits.

%%---------------------------------------------------------------------------%%
\section{Preliminaries\ }
\label{sec:nonlinear_preliminaries}
We formulate the \textit{nonlinear problem} as follows
\citep{knoll_jacobian-free_2004}:
\begin{equation}
  \ve{F}(\ve{u}) = \ve{0}\:,
  \label{eq:nonlinear_problem}
\end{equation}
where $\ve{u} \in \mathbb{R}^n$ is the solution vector and
$\ve{F}:\mathbb{R}^N \rightarrow \mathbb{R}^N$ is the function of
nonlinear residuals. We write the nonlinear system in this form so
that when an exact solution for $\ve{u}$ is achieved, all residuals
evaluate to zero. \textit{Newton's method} is a root finding algorithm
and therefore we can use it to solve Eq~(\ref{eq:nonlinear_problem})
if we interpret the exact solution $\ve{u}$ to be the roots of
$\ve{F}(\ve{u})$. Newton's method is also an iterative scheme, and we
can generate this procedure by building the Taylor expansion of the
$k+1$ iterate of the nonlinear residuals about the previous $k$
iterate:
\begin{equation}
  \ve{F}(\ve{u}^{k+1}) = \ve{F}(\ve{u}^{k}) +
  \ve{F}'(\ve{u}^{k})(\ve{u}^{k+1}-\ve{u}^{k}) +
  \frac{\ve{F}''(\ve{u}^{k})}{2}(\ve{u}^{k+1}-\ve{u}^{k})^2 + \cdots
  \:.
  \label{eq:newton_derivation_1}
\end{equation}
If we ignore the nonlinear terms in the expansion and assert that at
the $k+1$ iterate $\ve{u}^{k+1}$ is the exact solution such that
$\ve{F}(\ve{u}^{k+1}) = \ve{0}$, then we are left with the following
equality:
\begin{equation}
  -\ve{F}(\ve{u}^{k}) =
  \ve{F}'(\ve{u}^{k})(\ve{u}^{k+1}-\ve{u}^{k})\:.
  \label{eq:newton_derivation_2}
\end{equation}
We note two things of importance in
Eq~(\ref{eq:newton_derivation_2}). The first is that
$\ve{F}'(\ve{u}^{k})$ is in fact the \textit{Jacobian},
$\ve{J}(\ve{u})$, of the set of nonlinear residuals and is defined
element-wise as:
\begin{equation}
  J_{ij} = \frac{\partial F_i(\ve{u})}{\partial u_j}\:.
  \label{eq:jacobian_def}
\end{equation}
Second, we note that $(\ve{u}^{k+1}-\ve{u}^{k})$ is simply the
solution update from the $k$ iterate to the $k+1$ iterate. We will
define this update as the \textit{Newton correction} at the $k$
iterate, $\delta \ve{u}^k$. To finish, we can then rearrange
Eq~(\ref{eq:newton_derivation_2}) to define the Newton iteration
scheme for nonlinear problems:
\begin{subequations}
  \begin{gather}
    \ve{J}(\ve{u}) \delta \ve{u}^k = -\ve{F}(\ve{u}^{k})\\
    \ve{u}^{k+1} = \ve{u}^k + \delta \ve{u}^k\:.
  \end{gather}
  \label{eq:newton_iteration}
\end{subequations}
There are then three distinct steps to perform: evaluation of the
nonlinear residuals using the solution at the $k$ iterate, the
solution of a linear system to compute the Newton correction where the
Jacobian matrix of the nonlinear equation set is the linear operator,
and the application of the correction to the previous iterate's
solution to arrive at the next iterate's solution. In the asymptotic
limit, the iterations of Newton's method will converge the nonlinear
residual quadratically \citep{kelley_iterative_1995}. Convergence
criteria is set for stopping the iteration sequence based on the
nonlinear residual. Commonly, the following criteria is used:
\begin{equation}
  ||\ve{F}(\ve{u}^{k})|| < \epsilon ||\ve{F}(\ve{u}^{0})||\:,
  \label{eq:newton_stopping_criteria}
\end{equation}
where $\epsilon$ is a user defined tolerance parameter. Newton's
method is \textit{consistent} in that all components of the nonlinear
functions that describe the physics we are modeling are updated
simultaneously in the iteration sequence with respect to one
another. This is in comparison to \textit{inconsistent} strategies,
such as a pressure correction strategy for solving the Navier-Stokes
equations \citep{pletcher_computational_1997}, where the components of
$\ve{u}$ are updated in a staggered fashion depending on the
particular equations that they are associated with.

%%---------------------------------------------------------------------------%%
\section{The FANM Method\ }
\label{sec:fanm}
In production physics codes based on nonlinear equations sets,
Newton-Krylov methods are the primary means of generating a fully
consistent solution scheme
\citep{evans_development_2006,evans_enhanced_2007,gaston_parallel_2009,godoy_parallel_2012}. Typically,
for large scale simulations these problems are memory limited due to
the subspaces generated by robust Krylov methods. Often, a matrix-free
approach is chosen to relax memory requirements over directly
generating the Jacobian matrix and facilitate the
implementation. However, as we observed in previous sections, these
matrix-free methods suffer from poorly scaled problems and the first
order error introduced by the Jacobian approximation. In addition, it
was observed that the savings induced by the matrix-free approach is
eventually amortized over a number of nonlinear iterations where it
becomes more efficient computationally to instead form the Jacobian.

In Chapter~\ref{ch:stochastic_methods}, we focused our efforts on
developing and improving Monte Carlo methods for inverting linear
systems. These methods, when used to accelerate a stationary method in
MCSA, enjoy a robust implementation and exponential convergence
rates. Further, the only storage required is that of the full linear
system including the linear operator so that we may generate
transition probabilities for the random walk sequence. Although this
requires more storage to represent the linear system than that of a
Krylov method where the operator is not required, we do not incur any
additional storage costs once the iteration sequence begins. In the
context of nonlinear problems, the Jacobian matrix that we are
required to generate for the Monte Carlo solvers may be generated at
will from the nonlinear functions in the Newton system using automatic
differentiation. Not only do we then have a simple and automated way to
generate the Jacobian, but we also enjoy a Jacobian of numerical
precision equivalent to that of our function evaluations. We therefore
propose the \textit{Forward-Automated Newton-MCSA} (FANM) method that
utilizes all of the above components. We hypothesize that such a
method will be competitive with Newton-Krylov methods not only from a
convergence and timing perspective, but also relax scaling
requirements of matrix-free methods and memory costs of both
matrix-free and fully formed Jacobian methods to allow the application
developer to solve problems of finer discretization and higher-order
functional representations while maintaining a robust and efficient
parallel implementation.

\subsection{Parallel FANM Implementation}
\label{subsec:parallel_fanm}
A parallel FANM method relies on a basic set of parallel matrix-vector
operations as well as the global residual and Jacobian assembly
procedure described in
\S~\ref{subsubsec:automatic_differentiation}. Consider the Newton
iteration scheme in Eq~(\ref{eq:newton_iteration}). We must first
assemble the linear system in parallel through the element-wise
function evaluations to generate both the global Jacobian operator and
the global residual vector on the right hand side. Per Bartlett's
work, efficient and automated parallel mechanisms are available to do
this through a sequence of scatter/gather operations. With these tools
available for residual and Jacobian generation, the remainder of the
parallel procedure is simple, with the linear Newton correction system
solved using the parallel MCSA method as previously described and the
Newton correction applied to the previous iterate's solution through a
parallel vector update operation.

As Newton methods are formulated independent of the inner linear
solver generating the Newton corrections, the actual performance of
the nonlinear iterations using MCSA is expected to be similar to that
of traditional Newton-Krylov methods. Furthermore, we expect to
achieve numerically identical answers with a Newton-MCSA method as
other Newton methods and we should indeed verify this. The parallel
performance of such a method will inherently be bound to the parallel
Monte Carlo implementation of the linear solver as the parallel
operations at the nonlinear iteration level are identical to those
that you would perform with a Newton-Krylov method. Matrix-free
formulations will have different parallel performance than these
methods, and therefore we should compare FANM performance to JFNK-based
schemes. More important than performance in this situation is the
reduced memory pressure that a FANM implementation provides, as
discussed in \S~\ref{subsec:fanm_storage}, because a FANM method will
not generate a subspace in the linear solver and compressed storage
for sparse matrices are utilized, we expect significant memory savings
over Newton-Krylov methods. We must measure the memory utilization of
both of these methods in order to quantify their differences and
provide additional analysis of the FANM method's merits, or lack
thereof.

%%---------------------------------------------------------------------------%%
\section{Navier-Stokes Benchmark Problems\ }
\label{sec:ns_benchmarks}
To verify the FANM method for nonlinear problems, we choose benchmark
solutions for the 2-dimensional, steady, incompressible Navier-Stokes
equations on a rectilinear grid in much the same way as Shadid and
Pawlowski's work on Newton-Krylov methods for the solution of these
equations \citep{shadid_inexact_1997,pawlowski_globalization_2006}. We
define these equations as follows:
\begin{subequations}
  \begin{gather}
    \rho \ve{u} \cdot \nabla \ve{u} - \nabla \cdot \ve{T} - \rho
    \ve{g} = \ve{0}
    \label{eq:ns_momentum}\\
    \nabla \cdot \ve{u} = 0
    \label{eq:ns_continuity}\\
    \rho C_p \ve{u} \cdot \nabla T + \nabla \cdot \ve{q} = 0\:,
    \label{eq:ns_energy}
  \end{gather}
  \label{eq:navier_stokes}
\end{subequations}
where $\rho$ is the fluid density, $\ve{u}$ is the fluid velocity,
$\ve{g}$ gravity, $C_p$ the specific heat capacity at constant
pressure of the fluid and $T$ the temperature of the
fluid. Eq~(\ref{eq:ns_momentum}) provides momentum transport,
Eq~(\ref{eq:ns_continuity}) provides the mass balance, and
Eq~(\ref{eq:ns_energy}) provides energy transport with viscous
dissipation effects neglected. In addition, we close the system with
the following equations:
\begin{subequations}
  \begin{gather}
    \ve{T} = -P \ve{I} + \mu[\nabla \ve{u} + \nabla \ve{u}^T]
    \label{eq:ns_stress_tensor}\\
    \ve{q} = - k \nabla T\:,
    \label{eq:ns_heat_flux}
  \end{gather}
  \label{eq:ns_closure}
\end{subequations}
where $\ve{T}$ is the stress tensor, $P$ is the hydrodynamic pressure,
$\mu$ is the dynamic viscosity of the fluid, $\ve{q}$ is the heat flux
in the fluid, and $k$ is the thermal conductivity of the fluid. This
set of strongly coupled equations possesses both the nonlinearities
and asymmetries that we are seeking for qualification of the FANM
method. Further, physical parameters within these equations can be
tuned to enhance the nonlinearities. We will then apply these
equations to the following three standard benchmark problems.

\subsection{Thermal Convection Cavity Problem}
\label{subsec:natural_convection_cavity}
In 1983 a benchmark solution for the natural convection of air in a
square cavity was published \citep{de_vahl_davis_natural_1983} as
shown in Figure~\ref{fig:natural_convection_cavity} for the solution
of the energy, mass, and momentum equations.
\begin{figure}[t!]
  \begin{center}
    \scalebox{1.5}{
      \input{chapters/navier_stokes_solutions/natural_convection_cavity.pdftex_t} }
  \end{center}
  \caption{\textbf{Problem setup for the natural convection cavity
      benchmark.} \textit{Dirichlet conditions are set for the
      temperature on the left and right while Neumann conditions are
      set on the top and bottom of the Cartesian grid. The temperature
      gradients will cause buoyancy-driven flow. Zero velocity
      Dirichlet conditions are set on each boundary. No thermal source
      was present.}}
  \label{fig:natural_convection_cavity}
\end{figure}
In this problem, a rectilinear grid is applied to the unit square. No
heat flow is allowed out of the top and bottom of the square with a
zero Neumann condition specified. Buoyancy driven flow is generated by
the temperature gradient from the cold and hot Dirichlet conditions on
the left and right boundaries of the box. By adjusting the Rayleigh
number of the fluid (and therefore adjusting the ratio of convective
to conductive heat transfer), we can adjust the influence of the
nonlinear convection term in Eq~(\ref{eq:ns_momentum}). In Shadid's
work, Rayleigh numbers of up to \sn{1}{6} were used for this benchmark
on a $100 \times 100$ square mesh grid.

\subsection{Lid Driven Cavity Problem}
\label{subsec:lid_driven_cavity}
As an extension of the convection problem, the second benchmark
problem given by Ghia \citep{ghia_high-re_1982} adds a driver for the
flow to introduce higher Reynolds numbers into the system, providing
more inertial force to overcome the viscous forces in the fluid. The
setup for this problem is equally simple, containing only the
Dirichlet conditions as given in Figure~\ref{fig:lid_driven_cavity}
and is only applied to the mass and momentum equations on the unit
square.
\begin{figure}[t!]
  \begin{center}
    \scalebox{1.5}{
      \input{chapters/navier_stokes_solutions/lid_driven_cavity.pdftex_t} }
  \end{center}
  \caption{\textbf{Problem setup for the lid driven cavity benchmark.}
    \textit{Dirichlet conditions of zero are set for the velocity on
      the left and right and bottom while the Dirichlet condition set
      on the top provides a driving force on the fluid.}}
  \label{fig:lid_driven_cavity}
\end{figure}
The top boundary condition will provide a driver for the flow and its
variation will in turn vary the Reynolds number of the fluid. An
increased velocity will generate more inertial forces in the fluid,
which will overcome the viscous forces and again increase the
influence of the nonlinear terms in Eq~(\ref{eq:ns_momentum}). Shadid
also used a $100 \times 100$ grid for this benchmark problem with
Reynolds numbers up to \sn{1}{4}.

\subsection{Backward-Facing Step Problem}
\label{subsec:backward_facing_step}
The third benchmark was generated by Gartling in 1990 and consists of
both flow over a backward step and an outflow boundary condition
\citep{gartling_test_1990}. Using the mass and momentum equations
while neglecting the energy equation, this problem utilizes a longer
domain with a 1/30 aspect ratio with the boundary conditions as shown
in Figure~\ref{fig:backward_facing_step}.
\begin{figure}[t!]
  \begin{center}
    \scalebox{1.3}{
      \input{chapters/navier_stokes_solutions/backward_facing_step.pdftex_t} }
  \end{center}
  \caption{\textbf{Problem setup for the backward facing step
      benchmark.} \textit{Zero velocity boundary conditions are
      applied at the top and bottom of the domain while the outflow
      boundary condition on the right boundary is represented by zero
      stress tensor components in the direction of the flow. For the
      inlet conditions, the left boundary is split such that the top
      half has a fully formed parabolic flow profile and the bottom
      half has a zero velocity condition, simulating flow over a
      step.}}
  \label{fig:backward_facing_step}
\end{figure}
In this problem, the inflow condition is specified by a fully-formed
parabolic flow profile over a zero velocity boundary representing a
step. The flow over this step will generate a recirculating backflow
under the inlet flow towards the step. As in the lid driven cavity
problem, the nonlinear behavior of this benchmark and the difficulty
in obtaining a solution is dictated by the Reynolds number of the
fluid. In Shadid's work, a $20 \times 400$ non-square rectilinear grid
was used to discretize the domain with Reynolds number up to
\sn{5}{2}.

%%---------------------------------------------------------------------------%%
\section{FANM Verification\ }
\label{sec:fanm_verification}

%%---------------------------------------------------------------------------%%
\section{FANM Performance Comparison to Conventional Methods\ }
\label{sec:fanm_comparison}
